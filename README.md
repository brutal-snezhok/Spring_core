# Spring Framework - The Basics

### Содержание

- 1.<a href="https://www.youtube.com/watch?v=3wBteulZaAs"> 
Spring Architecture</a>
- 2.<a href="https://www.youtube.com/watch?v=IBNQ6whVHeI"> 
Dependency Injection</a>
- 3.<a href="https://www.youtube.com/watch?v=y-obHCFTbZ4">
Bean Naming and Context Start-up</a>
- 4.<a href="https://www.youtube.com/watch?v=kvcFK7criFc">
Scopes and Inner Beans</a>
- 5.<a href="https://www.youtube.com/watch?v=ygaboLsCKA4">
Initialize and Destroy</a>
***

### 1. Архитектура

#### Что такое Spring?

- **Набор легковесных jar-библиотек** Фреймворк состоит из набора jar файлов небольшого размера, которые представляют
отдельные компоненты Spring. Подключение различных модулей определяется целесообразностью их применения. Классы, которые
описываются в рамках решения поставленных бизнес-задач могут быть абсолютно независимы от Spring, таким образом исключая
жесткую связь с фреймворком.
- **Контейнер** Spring управляет жизненным циклом объектов, которые он создает, и которые в нем "живут". Нет
необходимости создавать зависимые объекты через ключевое слово *new*.
- **Фреймворк** Spring предоставляет множество решений, которые облегчают процесс разработки приложения, то есть
присутствует значительное количество утилитраных классов ,которые облегчают работу с базой данных, почтой, веб-сервисами
и т.д.
- **Внедрение зависимостей** Spring предоставляет имплементацию принципа инверсии контроля в виде dependency injection,
(внедрение зависимости) когда объекты не создают сами свои зависимости, а получают их из вне.
- **АОП**

#### Основные модули Spring

- **Core container** (spring-beans и spring-core - основные модули, управляют бинами и реализуют внедрение зависимостей;
spring-context - управление контекстом хранения бинов и обеспечение доступа к ним; spring-expression - язык для поиска и
модификации графа бинов во время выполнения программы)
- **AOP** (spring-aop - позволяет использовать аспектно-ориентированное программирование; spring-aspects - модуль
поддержки библиотеки AspectJ)
- **Instrumentation** (spring-instrument - модуль работы в application сервере (Tomcat, JBoss...))
- **Data access and integration** (spring-jdbc; spring-jms; spring-orm; spring-tx transaction)
- **Web & Remoting** (spring-web; spring-servlet; spring-struts)
- **Testing** (spring-test)

#### Проблемы приложения без использования Spring

- Приложение сложно модифицировать. Данные приложения "зашиты" непосредственно в код
- Невозможность масштабировать приложение
- Проблема тестирования приложения. Есть возможность неявного тестирования других модулей

Итого: наличие сильной связности

### 2. Внедрение зависимостей

#### Как решить полученные проблемы?

- Вынести все статические данные из кода во внешние файлы (имена пользователей и файлов, адреса серверов и т.д. - любая
информация, которая может когда-либо измениться) property или spring-конфигурация. Желательно чтобы это был текстовый
файл, это обусловлено удобством чтения/редактирования.
- Разъединить приложение на интерфейсы, это непосредственно поможет избежать сильной связности. Вызов методов сервисных
классов осужествлять через соответствующие интерфейсы. Классы не будут зависеть от конкретных реализаций. Интерфейсы не
создаются для классов хранящих информацию.
- Внедрение зависимостей. Все реализации интерфейсов предоставляются из вне. Сам Spring будет "подбрасывать" реализации
для интерфейсов.

#### Как изменится приложение?

- Класс App получает зависимые объекты, а не создает их сам.
- К объкту ConsoleEventLogger объект App будет обращаться через интерфейс, App не будет знать о том каким конкретно
EventLogger он пользуется (это позволит в любой момент изменить функциональность).
- Экземпляры App, ConsoleEventLogger и Client будут созданы Spring контейнером. Созданные Spring-ом объекты именуются
бинами (bean - фасоль), которые хранятся внутри контейнера. Spring также будет отвечать за то, чтобы объекты были
соединены между собой (проинжектит зависимости), а также проверит, чтобы между бинами не было циклических зависимостей.
- Работа приложения будет построена теперь таким образом, что необходимо обращаться за конкретным бином к контейнеру,
нет необходимости их создавать внутри приложения. Обращение к контейнеру как правило выполняется в начале работы
приложения.
- Как Spring поймет какие объекты создавать и как их связывать? Через файл описания Spring контейнера. Этот файл будет
содержать список бинов, которые необходимо создать, и инструкции о том как их связать. Существует три варианта описания
контейнера: xml-файл, аннотации и java код.
- Как выглядит xml-файл описания контейнера? Смотрите
<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html">
xsd-configuration</a>.

### 3. Именование бинов и старт контекста

- Имя бина указывается либо в атрибуте *<bean id="..."* или *<bean name="..."*, причем id может быть только один и
уникален, тогда как у атрибута name значений может быть сколько угодно много (обращение к бину по разным именам).
- Псевдоним (алиас) бина можно задать с помощью атрибута *<alias name="aaa" alias="bbb"/>*. Может пригодится при
подключении стороннего контекста, когда невозможно поменять имя.

#### Spring контейнеры

1. BeanFactory. Простейший контейнер, выполняющий только внедрение зависимостей (Поднимается, создает бины и инжектит
их в необходимые зависимости).
2. ApplicationContext. Поддерживает функциональность BeanFactory, и предоставляет вспомагательные/сервисные инструменты
фреймворка по управлению бинами.

- ClassPathXmlApplicationContext
- FileSystemXmlApplicationContext
- AnnotationConfigApplicationContext
- XmlWebApplicationContext
- StaticApplicationContext

### 4. Цикл жизни объекта в контейнере, внутренние бины

По умолчанию все бины в Spring - синглтоны. Но можно также применить аттрибут scope со значением *prototype*

*<bean id="..." class="..." scope="singleton"\/>*

*<bean id="..." class="..." scope="prototype"\/>*

Для веб-приложений также существуют цикл жизни:
- request
- session
- global-session

Внутренние бины видны только там, где они определены. Их нельзя переиспользовать. 

Если создание объекта происходит через статический фабричный метод, то необходимо воспользоваться конструкцией:
*<bean id="..." class="..." factory-method="..."\/>*

### 5. Инициализация и уничтожение

Перед тем как приложение начнет работать, но после того, как создадутся все бины, может понадобиться выполнение
определенных действий для инициализации отдельных бинов (например, проверка доступности каких-либо сторонних
ресурсов). 

Для выполнения подготовительных действий описывается инициализирующий метод в классе бина и в конфигурационном файле
spring.xml указывается атрибут init-method="...", значением которого будет имя инициализирующего метода.

- Инит-методы не принимают аргументов
- Инит-методы могут иметь любой модификатор доступа
- Инит-методы могут возвращать результата или выбрасывать исключения

При завершении программы может возникнуть необходимость выполнения определенных действий (освобождение ресурсов,
очистка кэша...). Для выполнения таго рода действий необходимо указать атрибут destroy-method="...". Чтобы все
дестрой-методы отработали спринг-контекст необходимо закрыть через метод close().

